---
title: "Visualisierung"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Visualisierung}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(TimeSeries)
library(tibble)
library(ggplot2)
```
In dieser Vignette geht es um die Illustration der Funktionen. Im ersten Teil werden die Fähigkeiten des Packetes *TimeSeries* durch eine Simulationsstudie dargestellt und im zweiten Teil auf reale Daten angewendet.  
 
# Simulationsstudie
 In dieser kurzen Simualtionsstudio werden die Fähigkeiten des Paketes durch kleine Veränderungen der Parameter veranschaulicht. 

## Autokovarianz-Funktion

In diesem Teil soll die Funktion *acf* getestet werden. Dazu wird ein AR(1)-Prozess mithilfe der Funktion *arma_sim* simuliert. Für diesen Prozess ist es leicht möglich die "wahre" theoretische Autokovarianz-Funktion zu berechnen.

### Theoretische ACF eines AR(1)-Prozesses

Wir nehmen an, dass die Zeitreihe der folgenden Vorraussetztung genügt, wobei $\epsilon$ die "white noise" ist:

$$
X_t=\phi X_{t-1}+\epsilon_t
$$
Für die Varianz $\gamma_0$ können folgende Berechnungen anstellen:

$$
\gamma(0)=Cov(X_t,X_t)=Cov(\phi X_{t-1}+\epsilon,\phi X_{t-1} + \epsilon_t)=\phi^2 \gamma(0) +\sigma^2= \frac{\sigma^2}{1-\phi^2}
$$
Nun sind auch die weiteren Autokovarianzen leicht bestimmbar:

$$
\gamma(h)=Cov(X_{t},X_{t-h})=Cov(\phi X_{t-1},X_{t-h})+Cov(\epsilon_t,X_{t-h})=\phi\gamma(h-1)+0=... = \phi^h \gamma(0)
$$
Es gilt also:
$$
\gamma(1)=Cov(X_{t},X_{t-1})=...=\phi \gamma_0
$$
$$
\gamma(2)=Cov(X_{t},X_{t-2})=...=\phi^2 \gamma_0
$$
$$
usw...
$$
(Brockwell Seite 17-18)
Wir berechnen nun die theoretischen ACF (ersten 50 Autokovarianzen) für den AR(1)-Prozess mit $\phi=0.9$. Wir verwenden keine Standardnormalverteilung für das Rauschen, daher gilt $\sigma_{\epsilon}^2=1$.

```{r fig1, fig.width = 7, fig.asp = .3}
gamma_0 <- 1/(1-0.9^2)
true_acf <- numeric(50)
for(i in 0:49){
        gamma_i <- gamma_0*0.9^i
        true_acf[i+1] <- gamma_i
}
true_tbl <- tibble(ACF=true_acf, Lag=seq_along(true_acf))
true_acf_plot <- ggplot(true_tbl, aes(x=Lag, y=ACF)) +
                geom_bar(stat="identity") + 
                ggtitle("Theoretische ACF: AR(1)")
true_acf_plot
```

Es ist die typische langsam abflachende Autokovarianzfunktion eines AR(1) zu erkennen.

### Vergleich von theoretischer mit geschätzter ACF

Wir simulieren nun Daten mit beschriebenen Eigenschaften und schätzen die ACF-Werte ab. Wir wollen testen wie sich die Zeitreihe mit unterschiedlichen Längen verhält. Dabei wollen wir untersuchen ab welcher Stichporbengröße sich der geschätze ACF-Wert dem theoretischen ACF annähert und betrachten dabei jeweils die ersten 50 Werte. Wir erstellen dafür eine Funktion welche die simulierten ACFs zusammen mit den theoretischen plottet. 

```{r , fig.width = 7, fig.asp = .5}
set.seed(13)
ar_50 <- arma_sim(phi=0.9,I=50, sd =1)
ar_100 <- arma_sim(phi=0.9,I=100, sd = 1)
ar_300 <- arma_sim(phi=0.9,I=300, sd =1)
ar_500 <- arma_sim(phi=0.9,I=500, sd =1)
ar_1000 <- arma_sim(phi=0.9,I=100, sd =1)
ar_2000 <- arma_sim(phi=0.9,I=2000, sd =1)
ar_5000 <- arma_sim(phi=0.9,I=5000, sd =1)

acf_plot <- function(objekt, ...){
        sim_tbl <- tibble(ACF=ACF(objekt)[1:50],Lag=1:50)
        sim_tbl$Group <- "Simulation"
        
        true_tbl <- tibble(ACF=true_acf,Lag=1:50)
        true_tbl$Group <- "Theoretical"
        
        tbl <- rbind(sim_tbl, true_tbl)
        
        acf_plot <- ggplot(tbl, aes(x=factor(Lag), y=ACF, fill=Group)) +
                geom_bar(stat='identity', position='dodge') + 
                ggtitle(...) +
                scale_x_discrete(name="Lag", breaks=seq(0,50,5))
acf_plot
}
acf_plot(ar_50, "Länge 50") 
acf_plot(ar_100, "Länge 100")
acf_plot(ar_300, "Länge 300")
acf_plot(ar_500, "Länge 500")
acf_plot(ar_1000, "Länge 1000")
acf_plot(ar_2000, "Länge 2000")
acf_plot(ar_5000, "Länge 5000")
```
Als zusätzliche veranschaulichung zeigt dieser Plot den Zusammenhang zwischen der Länge der Zeitreihe und der Differenz zwischen den theoretischen und simulierten Werten an.

```{r , fig.width = 7, fig.asp = .5}
set.seed(13)
acf_diff_plot <- function(n){
        res <- tibble(Länge=n,Differenz=numeric(n))
        zähler <- 1
        for(i in 1:n){
          a <- ACF(arma_sim(phi=0.9,I=i*50, sd =1))
          diff <- sum(abs(a[1:50]-true_acf))
          res$Länge[zähler] <- i*50
          res$Differenz[zähler] <- diff
          zähler <- zähler+1
        }

        acf_plot <- ggplot(res,aes(x=Länge,y=Differenz)) +
          geom_bar(stat='identity', position='dodge') +
          ggtitle("Differenz simulierten und theoretischen Daten")
          
        acf_plot
}
######################unebdingt reinmachen nur in Klammer wegen langer berechnungszeit!!!!!!!
#acf_diff_plot(100)
```


Der obige Vergleich zeigt deutlich, dass sich die geschätzte ACF dem theoretischen ACF des AR(1)-Prozesses bei höher Länge annähert. Die Uebereinstiummung nimmt bis zu einer Länge der AR(1)-Reihe von 1000 sichtbar zu. Ab diesem Zeitpunkt oszilliert die Differenz auf erstaunlicherweise relativ hohen Niveau. Wir nehmen an, dass diese Oszillation durch den zugrundeliegenden Zufallsprozess erzeugt wird.  

# Durbin-Levinson Algorithmus
